package com.example.codestreak;

import android.graphics.Color;
import android.os.Bundle;
import android.view.View;
import android.widget.ImageButton;
import android.widget.TextView;
import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.GridLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import com.github.mikephil.charting.charts.PieChart;
import com.github.mikephil.charting.data.PieData;
import com.github.mikephil.charting.data.PieDataSet;
import com.github.mikephil.charting.data.PieEntry;
import com.github.mikephil.charting.formatter.PercentFormatter;
import com.github.mikephil.charting.utils.ColorTemplate;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.Random;

public class MainActivity extends AppCompatActivity {
    
    private PieChart pieChart;
    private RecyclerView contributionGrid;
    private TextView totalProblemsText, easyCountText, mediumCountText, hardCountText;
    private TextView currentStreakText, longestStreakText;
    private TextView monthYearText;
    private ImageButton prevMonthButton, nextMonthButton;
    
    // Monthly navigation
    private Calendar currentMonthCalendar;
    private UltraSimpleAdapter contributionAdapter;
    private LeetCodeAPI leetCodeAPI;
    
    // Sample data
    private int easyProblems = 45;
    private int mediumProblems = 32;
    private int hardProblems = 18;
    private int totalProblems = easyProblems + mediumProblems + hardProblems;
    private int currentStreak = 7;
    private int longestStreak = 24;
    
    // Real submission calendar data from LeetCode
    private org.json.JSONObject submissionCalendarData;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        // Initialize current month to current date
        currentMonthCalendar = Calendar.getInstance();
        
        // Initialize LeetCode API
        leetCodeAPI = new LeetCodeAPI();
        
        initViews();
        setupPieChart();
        setupContributionGrid();
        updateStats();
        setupMonthNavigation();
        
        // Test with a different API call first
        testLeetCodeConnection();
        
        // Debug current timestamp for August 2025
        debugAugust2025Timestamps();
        
        // Force test data for August to verify coloring works
        forceTestDataForAugust();
        
        // Try multiple usernames or use sample data with a delay
        tryFetchDataWithFallback();
    }
    
    private void initViews() {
        pieChart = findViewById(R.id.pieChart);
        contributionGrid = findViewById(R.id.contributionGrid);
        totalProblemsText = findViewById(R.id.totalProblemsText);
        easyCountText = findViewById(R.id.easyCountText);
        mediumCountText = findViewById(R.id.mediumCountText);
        hardCountText = findViewById(R.id.hardCountText);
        currentStreakText = findViewById(R.id.currentStreakText);
        longestStreakText = findViewById(R.id.longestStreakText);
        monthYearText = findViewById(R.id.monthYearText);
        prevMonthButton = findViewById(R.id.prevMonthButton);
        nextMonthButton = findViewById(R.id.nextMonthButton);
    }
    
    private void setupPieChart() {
        ArrayList<PieEntry> entries = new ArrayList<>();
        entries.add(new PieEntry(easyProblems, "Easy"));
        entries.add(new PieEntry(mediumProblems, "Medium"));
        entries.add(new PieEntry(hardProblems, "Hard"));
        
        PieDataSet dataSet = new PieDataSet(entries, "");
        
        // Enhanced gradient-like colors
        dataSet.setColors(new int[]{
            getResources().getColor(R.color.easy_color),
            getResources().getColor(R.color.medium_color),
            getResources().getColor(R.color.hard_color)
        });
        
        // Add gradient effect with color variations
        dataSet.setSelectionShift(12f);
        dataSet.setDrawIcons(false);
        
        // Enhanced styling for better appearance
        dataSet.setValueTextColor(Color.WHITE);
        dataSet.setValueTextSize(16f);
        dataSet.setValueTypeface(android.graphics.Typeface.DEFAULT_BOLD);
        dataSet.setSliceSpace(5f);
        dataSet.setValueLinePart1OffsetPercentage(85f);
        dataSet.setValueLinePart1Length(0.3f);
        dataSet.setValueLinePart2Length(0.5f);
        dataSet.setYValuePosition(PieDataSet.ValuePosition.OUTSIDE_SLICE);
        
        // Custom value formatter to show count instead of percentage
        PieData pieData = new PieData(dataSet);
        pieData.setValueFormatter(new com.github.mikephil.charting.formatter.ValueFormatter() {
            @Override
            public String getFormattedValue(float value) {
                return String.valueOf((int) value);
            }
        });
        pieData.setValueTextSize(16f);
        pieData.setValueTextColor(Color.WHITE);
        
        pieChart.setData(pieData);
        pieChart.getDescription().setEnabled(false);
        
        // Enhanced hole styling with more space for center text
        pieChart.setDrawHoleEnabled(true);
        pieChart.setHoleColor(getResources().getColor(R.color.leetcode_card_bg));
        pieChart.setHoleRadius(60f);
        pieChart.setTransparentCircleRadius(65f);
        pieChart.setTransparentCircleColor(getResources().getColor(R.color.leetcode_dark_bg));
        pieChart.setTransparentCircleAlpha(80);
        
        // Enhanced center text with better formatting and larger size
        pieChart.setDrawCenterText(true);
        String centerText = String.format("%d\nTotal\nProblems", totalProblems);
        pieChart.setCenterText(centerText);
        pieChart.setCenterTextColor(getResources().getColor(R.color.leetcode_text_primary));
        pieChart.setCenterTextSize(14f);
        pieChart.setCenterTextTypeface(android.graphics.Typeface.DEFAULT_BOLD);
        pieChart.setCenterTextOffset(0, 0);
        
        // Disable legend and interactions for cleaner look
        pieChart.getLegend().setEnabled(false);
        pieChart.setRotationAngle(0f);
        pieChart.setRotationEnabled(false);
        pieChart.setHighlightPerTapEnabled(true);
        pieChart.setDrawEntryLabels(false);
        pieChart.setUsePercentValues(false);
        
        // Add extra margins to prevent text clipping
        pieChart.setExtraOffsets(15f, 15f, 15f, 15f);
        
        // Enhanced animation with combined effects
        pieChart.animateXY(1400, 1400, 
            com.github.mikephil.charting.animation.Easing.EaseInOutCubic, 
            com.github.mikephil.charting.animation.Easing.EaseInOutCubic);
        
        // Add custom marker view for tap interactions
        CustomMarkerView markerView = new CustomMarkerView(this);
        pieChart.setMarker(markerView);
        
        // Add subtle touch feedback
        pieChart.setMaxHighlightDistance(100f);
        pieChart.setDrawSliceText(false);
    }
    
    private void setupContributionGrid() {
        // 7 columns for days of the week
        contributionGrid.setLayoutManager(new GridLayoutManager(this, 7));
        
        // Generate monthly contribution data (will use real data after API call)
        ArrayList<Integer> contributionData;
        if (submissionCalendarData != null) {
            contributionData = generateRealMonthlyContributionData(currentMonthCalendar);
        } else {
            contributionData = generateMonthlyContributionData(currentMonthCalendar);
        }
        
        // USE ENHANCED ULTRA SIMPLE ADAPTER WITH REAL DATA SUPPORT
        contributionAdapter = new UltraSimpleAdapter(contributionData, currentMonthCalendar);
        contributionGrid.setAdapter(contributionAdapter);
        
        System.out.println("SETUP: Using enhanced UltraSimpleAdapter with real data support");
    }
    
    private void setupMonthNavigation() {
        updateMonthYearText();
        
        prevMonthButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                currentMonthCalendar.add(Calendar.MONTH, -1);
                updateContributionGrid();
                updateMonthYearText();
            }
        });
        
        nextMonthButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                currentMonthCalendar.add(Calendar.MONTH, 1);
                updateContributionGrid();
                updateMonthYearText();
            }
        });
    }
    
    private void updateMonthYearText() {
        SimpleDateFormat monthYearFormat = new SimpleDateFormat("MMMM yyyy", Locale.getDefault());
        monthYearText.setText(monthYearFormat.format(currentMonthCalendar.getTime()));
    }
    
    private void updateContributionGrid() {
        ArrayList<Integer> contributionData;
        
        // Use real data if available, otherwise generate sample data
        if (submissionCalendarData != null) {
            System.out.println("DEBUG: Using real submission data for contribution grid");
            contributionData = generateRealMonthlyContributionData(currentMonthCalendar);
        } else {
            System.out.println("DEBUG: Using sample data for contribution grid");
            contributionData = generateMonthlyContributionData(currentMonthCalendar);
        }
        
        // Debug the data being passed to adapter
        System.out.println("DEBUG: Contribution data summary:");
        int activeCount = 0;
        for (int i = 0; i < contributionData.size(); i++) {
            if (contributionData.get(i) > 0) {
                activeCount++;
                System.out.println("  Position " + i + ": " + contributionData.get(i) + " problems");
            }
        }
        System.out.println("DEBUG: Total active cells: " + activeCount + " out of " + contributionData.size());
        
        contributionAdapter.updateData(contributionData, currentMonthCalendar);
    }
    
    private ArrayList<Integer> generateMonthlyContributionData(Calendar monthCalendar) {
        ArrayList<Integer> data = new ArrayList<>();
        Random random = new Random();
        
        // Clone the calendar to avoid modifying the original
        Calendar cal = (Calendar) monthCalendar.clone();
        
        // Set to first day of the month
        cal.set(Calendar.DAY_OF_MONTH, 1);
        
        // Get the first day of week for this month (Sunday = 1, Monday = 2, etc.)
        int firstDayOfWeek = cal.get(Calendar.DAY_OF_WEEK);
        
        // Add empty cells for days before the month starts
        for (int i = 1; i < firstDayOfWeek; i++) {
            data.add(-1); // -1 represents empty cell
        }
        
        // Get number of days in this month
        int daysInMonth = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
        
        // Add data for each day of the month
        for (int day = 1; day <= daysInMonth; day++) {
            cal.set(Calendar.DAY_OF_MONTH, day);
            int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);
            
            int problems;
            
            // Ensure some guaranteed activity for coloring
            if (day % 7 == 0) {
                problems = 1 + random.nextInt(3); // 1-3 problems every 7th day
            } else if (day % 10 == 0) {
                problems = 3 + random.nextInt(4); // 3-6 problems every 10th day
            } else if (day == 1 || day == 15 || day == monthCalendar.get(Calendar.DAY_OF_MONTH)) {
                problems = 2 + random.nextInt(3); // 2-4 problems on 1st, 15th, and today
            } else {
                if (dayOfWeek == Calendar.SATURDAY || dayOfWeek == Calendar.SUNDAY) {
                    problems = random.nextInt(5); // 0-4 problems on weekends
                } else {
                    problems = random.nextInt(6); // 0-5 problems on weekdays
                }
            }
            
            data.add(problems);
        }
        
        // Fill remaining cells to complete the grid (6 weeks max)
        int totalCells = 42; // 6 weeks * 7 days
        while (data.size() < totalCells) {
            data.add(-1); // Empty cells after the month
        }
        
        return data;
    }
    
    /**
     * Generate real monthly contribution data from LeetCode submission calendar
     * IMPROVED: Generic solution that properly converts LeetCode timestamps
     */
    private ArrayList<Integer> generateRealMonthlyContributionData(Calendar monthCalendar) {
        ArrayList<Integer> data = new ArrayList<>();
        
        if (submissionCalendarData == null) {
            System.out.println("DEBUG: No submission calendar data, using sample data");
            return generateMonthlyContributionData(monthCalendar); // Fallback to sample data
        }
        
        try {
            String monthName = new SimpleDateFormat("MMMM yyyy", Locale.getDefault()).format(monthCalendar.getTime());
            System.out.println("DEBUG: Generating real monthly data for: " + monthName);
            
            // Clone the calendar to avoid modifying the original
            Calendar cal = (Calendar) monthCalendar.clone();
            
            // Set to first day of the month
            cal.set(Calendar.DAY_OF_MONTH, 1);
            cal.set(Calendar.HOUR_OF_DAY, 0);
            cal.set(Calendar.MINUTE, 0);
            cal.set(Calendar.SECOND, 0);
            cal.set(Calendar.MILLISECOND, 0);
            
            // Get the first day of week for this month (Sunday = 1, Monday = 2, etc.)
            int firstDayOfWeek = cal.get(Calendar.DAY_OF_WEEK);
            
            // Add empty cells for days before the month starts
            for (int i = 1; i < firstDayOfWeek; i++) {
                data.add(-1); // -1 represents empty cell
            }
            
            // Get number of days in this month
            int daysInMonth = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
            int realDataCount = 0;
            
            System.out.println("DEBUG: Checking " + daysInMonth + " days for submissions...");
            
            // IMPROVED: Convert all LeetCode timestamps to dates first
            Map<String, Integer> dateSubmissions = new HashMap<>();
            
            // Parse all timestamps from LeetCode data
            Iterator<String> keys = submissionCalendarData.keys();
            while (keys.hasNext()) {
                String timestampStr = keys.next();
                try {
                    long timestamp = Long.parseLong(timestampStr);
                    Date date = new Date(timestamp * 1000); // Convert to milliseconds
                    
                    // Format as YYYY-MM-DD
                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
                    String dateKey = sdf.format(date);
                    
                    int submissions = submissionCalendarData.getInt(timestampStr);
                    dateSubmissions.put(dateKey, submissions);
                    
                    System.out.println("DEBUG: Converted timestamp " + timestamp + " -> " + dateKey + " -> " + submissions + " submissions");
                } catch (Exception e) {
                    System.out.println("DEBUG: Failed to parse timestamp: " + timestampStr);
                }
            }
            
            // Now match days in the current month
            int targetYear = monthCalendar.get(Calendar.YEAR);
            int targetMonth = monthCalendar.get(Calendar.MONTH) + 1; // Calendar months are 0-based
            
            for (int day = 1; day <= daysInMonth; day++) {
                String dateKey = String.format("%04d-%02d-%02d", targetYear, targetMonth, day);
                
                int submissions = 0;
                if (dateSubmissions.containsKey(dateKey)) {
                    submissions = dateSubmissions.get(dateKey);
                    realDataCount++;
                    System.out.println("DEBUG: " + dateKey + " has " + submissions + " submissions");
                }
                
                data.add(submissions);
            }
            
            // Fill remaining cells to complete the grid (6 weeks max)
            int totalCells = 42; // 6 weeks * 7 days
            while (data.size() < totalCells) {
                data.add(-1); // Empty cells after the month
            }
            
            System.out.println("DEBUG: Generated " + data.size() + " cells with " + realDataCount + " days having submissions");
            
            return data;
            
        } catch (Exception e) {
            System.out.println("DEBUG: Error generating real monthly data: " + e.getMessage());
            e.printStackTrace();
            return generateMonthlyContributionData(monthCalendar); // Fallback to sample data
        }
    }
                    String.valueOf(timestamp - 86400), // Previous day
                    String.valueOf(timestamp + 86400)  // Next day
                };
                
                for (String timestampKey : timestampKeys) {
                    if (submissionCalendarData.has(timestampKey)) {
                        int count = submissionCalendarData.getInt(timestampKey);
                        if (count > submissions) {
                            submissions = count;
                        }
                    }
                }
                
                // Also try with local timezone adjustment
                Calendar localCal = Calendar.getInstance();
                localCal.set(monthCalendar.get(Calendar.YEAR), 
                           monthCalendar.get(Calendar.MONTH), 
                           day, 12, 0, 0); // Use noon to avoid timezone issues
                long localTimestamp = localCal.getTimeInMillis() / 1000;
                String localKey = String.valueOf(localTimestamp);
                
                if (submissionCalendarData.has(localKey)) {
                    int count = submissionCalendarData.getInt(localKey);
                    if (count > submissions) {
                        submissions = count;
                    }
                }
                
                if (submissions > 0) {
                    realDataCount++;
                    System.out.println("DEBUG: Day " + day + " has " + submissions + " submissions (timestamp: " + timestamp + ")");
                }
                
                data.add(submissions);
            }
            
            // Fill remaining cells to complete the grid (6 weeks max)
            int totalCells = 42; // 6 weeks * 7 days
            while (data.size() < totalCells) {
                data.add(-1); // Empty cells after the month
            }
            
            System.out.println("DEBUG: Generated " + data.size() + " cells with " + realDataCount + " days having submissions");
            
            // If we found no real data, let's debug the submission calendar
            if (realDataCount == 0) {
                System.out.println("DEBUG: No submissions found for this month. Available timestamps:");
                java.util.Iterator<String> keys = submissionCalendarData.keys();
                int count = 0;
                while (keys.hasNext() && count < 10) {
                    String key = keys.next();
                    int value = submissionCalendarData.getInt(key);
                    if (value > 0) {
                        long ts = Long.parseLong(key);
                        Date date = new Date(ts * 1000);
                        System.out.println("  " + key + " -> " + value + " submissions on " + date);
                        count++;
                    }
                }
            }
            
        } catch (Exception e) {
            System.out.println("ERROR: Failed to generate real monthly data: " + e.getMessage());
            e.printStackTrace();
            return generateMonthlyContributionData(monthCalendar); // Fallback to sample data
        }
        
        return data;
    }
    
    /**
     * Calculate current and longest streaks from real submission calendar data
     */
    private void calculateStreaksFromCalendar() {
        if (submissionCalendarData == null) {
            return;
        }
        
        try {
            Calendar today = Calendar.getInstance();
            today.set(Calendar.HOUR_OF_DAY, 0);
            today.set(Calendar.MINUTE, 0);
            today.set(Calendar.SECOND, 0);
            today.set(Calendar.MILLISECOND, 0);
            
            // Calculate current streak (consecutive days from today backwards)
            int currentStreakCount = 0;
            Calendar checkDate = (Calendar) today.clone();
            
            // Check today and previous days
            while (true) {
                long timestamp = checkDate.getTimeInMillis() / 1000;
                String timestampKey = String.valueOf(timestamp);
                
                if (submissionCalendarData.has(timestampKey) && 
                    submissionCalendarData.getInt(timestampKey) > 0) {
                    currentStreakCount++;
                    checkDate.add(Calendar.DAY_OF_MONTH, -1);
                } else {
                    // If today has no submissions, check yesterday
                    if (currentStreakCount == 0 && checkDate.equals(today)) {
                        checkDate.add(Calendar.DAY_OF_MONTH, -1);
                        continue;
                    }
                    break;
                }
            }
            
            // Calculate longest streak
            int longestStreakCount = 0;
            int tempStreak = 0;
            
            // Get all timestamps and sort them
            java.util.Iterator<String> keys = submissionCalendarData.keys();
            java.util.List<Long> timestamps = new java.util.ArrayList<>();
            
            while (keys.hasNext()) {
                String key = keys.next();
                if (submissionCalendarData.getInt(key) > 0) {
                    timestamps.add(Long.parseLong(key));
                }
            }
            
            java.util.Collections.sort(timestamps);
            
            // Calculate longest consecutive streak
            for (int i = 0; i < timestamps.size(); i++) {
                if (i == 0) {
                    tempStreak = 1;
                } else {
                    long prevDay = timestamps.get(i - 1);
                    long currentDay = timestamps.get(i);
                    
                    // Check if current day is consecutive (86400 seconds = 1 day)
                    if (currentDay - prevDay <= 86400) {
                        tempStreak++;
                    } else {
                        longestStreakCount = Math.max(longestStreakCount, tempStreak);
                        tempStreak = 1;
                    }
                }
            }
            longestStreakCount = Math.max(longestStreakCount, tempStreak);
            
            // Update streak values
            currentStreak = currentStreakCount;
            longestStreak = longestStreakCount;
            
        } catch (Exception e) {
            e.printStackTrace();
            // Keep original streak values if calculation fails
        }
    }
    
    private void updateStats() {
        totalProblemsText.setText(String.valueOf(totalProblems));
        easyCountText.setText(String.valueOf(easyProblems));
        mediumCountText.setText(String.valueOf(mediumProblems));
        hardCountText.setText(String.valueOf(hardProblems));
        currentStreakText.setText(String.valueOf(currentStreak));
        longestStreakText.setText(String.valueOf(longestStreak));
    }
    
    /**
     * Fetch real data from LeetCode including submission calendar
     * Replace "username" with actual LeetCode username
     */
    private void fetchUserDataFromLeetCode(String username) {
        System.out.println("DEBUG: Starting API call for user: " + username);
        
        // Fetch user stats and submission calendar
        leetCodeAPI.getUserSubmissionStats(username, new LeetCodeAPI.LeetCodeCallback() {
            @Override
            public void onSuccess(String response) {
                System.out.println("DEBUG: API call successful");
                // Run on UI thread to update UI
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            parseAndUpdateUserData(response);
                        } catch (Exception e) {
                            System.out.println("ERROR: Failed to parse data on UI thread: " + e.getMessage());
                            e.printStackTrace();
                            // Fallback to sample data if parsing fails
                        }
                    }
                });
            }
            
            @Override
            public void onError(Exception error) {
                System.out.println("ERROR: API call failed: " + error.getMessage());
                error.printStackTrace();
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        // Handle error - maybe show a toast or use sample data
                        System.out.println("Using sample data due to API error");
                        // Keep using sample data that's already initialized
                        updateStats();
                        setupPieChart();
                        updateContributionGrid();
                    }
                });
            }
        });
    }
    
    /**
     * Parse LeetCode API response and update UI with real data
     */
    private void parseAndUpdateUserData(String jsonResponse) {
        try {
            System.out.println("DEBUG: Received API response: " + jsonResponse.substring(0, Math.min(200, jsonResponse.length())) + "...");
            
            org.json.JSONObject response = new org.json.JSONObject(jsonResponse);
            org.json.JSONObject data = response.getJSONObject("data");
            org.json.JSONObject matchedUser = data.getJSONObject("matchedUser");
            
            // Parse submission statistics
            org.json.JSONObject submitStats = matchedUser.getJSONObject("submitStats");
            org.json.JSONArray acSubmissionNum = submitStats.getJSONArray("acSubmissionNum");
            
            // Reset counters
            int newEasy = 0, newMedium = 0, newHard = 0;
            
            // Parse submission data
            for (int i = 0; i < acSubmissionNum.length(); i++) {
                org.json.JSONObject submission = acSubmissionNum.getJSONObject(i);
                String difficulty = submission.getString("difficulty");
                int count = submission.getInt("count");
                
                System.out.println("DEBUG: Found " + count + " " + difficulty + " problems");
                
                switch (difficulty) {
                    case "Easy":
                        newEasy = count;
                        break;
                    case "Medium":
                        newMedium = count;
                        break;
                    case "Hard":
                        newHard = count;
                        break;
                }
            }
            
            // Update problem counts
            easyProblems = newEasy;
            mediumProblems = newMedium;
            hardProblems = newHard;
            totalProblems = easyProblems + mediumProblems + hardProblems;
            
            System.out.println("DEBUG: Updated counts - Easy: " + easyProblems + ", Medium: " + mediumProblems + ", Hard: " + hardProblems);
            
            // Parse submission calendar data
            if (matchedUser.has("submissionCalendar")) {
                String submissionCalendar = matchedUser.getString("submissionCalendar");
                System.out.println("DEBUG: Submission calendar length: " + submissionCalendar.length());
                System.out.println("DEBUG: Submission calendar preview: " + submissionCalendar.substring(0, Math.min(200, submissionCalendar.length())));
                
                if (submissionCalendar != null && !submissionCalendar.isEmpty() && !submissionCalendar.equals("null")) {
                    submissionCalendarData = new org.json.JSONObject(submissionCalendar);
                    System.out.println("DEBUG: Parsed " + submissionCalendarData.length() + " calendar entries");
                    
                    // Debug: Show some recent entries
                    java.util.Iterator<String> keys = submissionCalendarData.keys();
                    int debugCount = 0;
                    System.out.println("DEBUG: Recent submission entries:");
                    while (keys.hasNext() && debugCount < 5) {
                        String key = keys.next();
                        int value = submissionCalendarData.getInt(key);
                        if (value > 0) {
                            long timestamp = Long.parseLong(key);
                            Date date = new Date(timestamp * 1000L);
                            System.out.println("  " + key + " -> " + value + " submissions on " + date);
                            debugCount++;
                        }
                    }
                    
                    // Calculate streaks from calendar data
                    calculateStreaksFromCalendar();
                } else {
                    System.out.println("DEBUG: No submission calendar data available");
                }
            } else {
                System.out.println("DEBUG: submissionCalendar field not found in response");
            }
            
            // Refresh UI components
            updateStats();
            setupPieChart();
            updateContributionGrid(); // Update with real data
            
            System.out.println("DEBUG: UI updated successfully");
            
        } catch (Exception e) {
            System.out.println("ERROR: Failed to parse user data: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Parse basic user data without submission calendar
     */
    private void parseBasicUserData(String jsonResponse) {
        try {
            System.out.println("DEBUG: Parsing basic user data...");
            
            org.json.JSONObject response = new org.json.JSONObject(jsonResponse);
            org.json.JSONObject data = response.getJSONObject("data");
            org.json.JSONObject matchedUser = data.getJSONObject("matchedUser");
            
            if (matchedUser.has("submitStats")) {
                org.json.JSONObject submitStats = matchedUser.getJSONObject("submitStats");
                org.json.JSONArray acSubmissionNum = submitStats.getJSONArray("acSubmissionNum");
                
                int newEasy = 0, newMedium = 0, newHard = 0;
                
                for (int i = 0; i < acSubmissionNum.length(); i++) {
                    org.json.JSONObject submission = acSubmissionNum.getJSONObject(i);
                    String difficulty = submission.getString("difficulty");
                    int count = submission.getInt("count");
                    
                    switch (difficulty) {
                        case "Easy": newEasy = count; break;
                        case "Medium": newMedium = count; break;
                        case "Hard": newHard = count; break;
                    }
                }
                
                // Update problem counts
                easyProblems = newEasy;
                mediumProblems = newMedium;
                hardProblems = newHard;
                totalProblems = easyProblems + mediumProblems + hardProblems;
                
                System.out.println("DEBUG: Basic data - Easy: " + easyProblems + ", Medium: " + mediumProblems + ", Hard: " + hardProblems);
                
                // Update UI
                updateStats();
                setupPieChart();
            }
            
        } catch (Exception e) {
            System.out.println("ERROR: Failed to parse basic user data: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Fetch today's daily coding challenge
     */
    private void fetchDailyChallenge() {
        leetCodeAPI.getDailyCodingChallenge(new LeetCodeAPI.LeetCodeCallback() {
            @Override
            public void onSuccess(String response) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            parseDailyChallengeData(response);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                });
            }
            
            @Override
            public void onError(Exception error) {
                System.out.println("Error fetching daily challenge: " + error.getMessage());
            }
        });
    }
    
    /**
     * Parse daily challenge data
     */
    private void parseDailyChallengeData(String jsonResponse) {
        try {
            org.json.JSONObject response = new org.json.JSONObject(jsonResponse);
            org.json.JSONObject data = response.getJSONObject("data");
            org.json.JSONObject challenge = data.getJSONObject("activeDailyCodingChallengeQuestion");
            org.json.JSONObject question = challenge.getJSONObject("question");
            
            String title = question.getString("title");
            String difficulty = question.getString("difficulty");
            String titleSlug = question.getString("titleSlug");
            
            // You can use this data to show daily challenge in your UI
            System.out.println("Today's Challenge: " + title + " (" + difficulty + ")");
            System.out.println("URL: https://leetcode.com/problems/" + titleSlug + "/");
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    /**
     * Fetch problems by difficulty for practice
     */
    private void fetchProblemsByDifficulty(String difficulty) {
        leetCodeAPI.getProblemsByDifficulty(difficulty, new LeetCodeAPI.LeetCodeCallback() {
            @Override
            public void onSuccess(String response) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            parseProblemsData(response);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                });
            }
            
            @Override
            public void onError(Exception error) {
                System.out.println("Error fetching problems: " + error.getMessage());
            }
        });
    }
    
    /**
     * Parse problems data
     */
    private void parseProblemsData(String jsonResponse) {
        try {
            org.json.JSONObject response = new org.json.JSONObject(jsonResponse);
            org.json.JSONObject data = response.getJSONObject("data");
            org.json.JSONObject problemsetQuestionList = data.getJSONObject("problemsetQuestionList");
            org.json.JSONArray questions = problemsetQuestionList.getJSONArray("questions");
            
            // Process questions array
            for (int i = 0; i < questions.length(); i++) {
                org.json.JSONObject question = questions.getJSONObject(i);
                String title = question.getString("title");
                String difficulty = question.getString("difficulty");
                String titleSlug = question.getString("titleSlug");
                boolean isPaidOnly = question.getBoolean("paidOnly");
                
                if (!isPaidOnly) {
                    System.out.println(title + " (" + difficulty + ") - " + titleSlug);
                }
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    /**
     * Debug method to understand timestamp conversion for August 2025
     */
    private void debugAugust2025Timestamps() {
        System.out.println("DEBUG: August 2025 timestamp analysis:");
        
        Calendar cal = Calendar.getInstance();
        cal.set(2025, Calendar.AUGUST, 1, 0, 0, 0);
        cal.set(Calendar.MILLISECOND, 0);
        
        for (int day = 1; day <= 31; day++) {
            cal.set(Calendar.DAY_OF_MONTH, day);
            long timestamp = cal.getTimeInMillis() / 1000;
            
            System.out.println("Aug " + day + ", 2025 -> " + timestamp + " (" + new Date(timestamp * 1000) + ")");
            
            if (day > 5) break; // Just show first few days
        }
        
        // Today's timestamp
        Calendar today = Calendar.getInstance();
        System.out.println("Today (" + today.getTime() + ") -> " + (today.getTimeInMillis() / 1000));
    }
    
    /**
     * Force test data for August to verify coloring works
     */
    private void forceTestDataForAugust() {
        System.out.println("DEBUG: Forcing test data for August 2025 coloring verification");
        
        // Set current month to August 2025 for testing
        Calendar testCalendar = Calendar.getInstance();
        testCalendar.set(2025, Calendar.AUGUST, 26); // Set to today (August 26, 2025)
        currentMonthCalendar = testCalendar;
        
        // Force update the month display and grid immediately
        new android.os.Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        updateMonthYearText();
                        updateContributionGrid();
                        System.out.println("DEBUG: Forced August 2025 test data applied");
                    }
                });
            }
        }, 1000); // 1 second delay to ensure UI is ready
    }
    
    /**
     * Test LeetCode connection with a simple API call
     */
    private void testLeetCodeConnection() {
        System.out.println("DEBUG: Testing LeetCode API connection...");
        
        // First try to get daily challenge (doesn't require username)
        leetCodeAPI.getDailyCodingChallenge(new LeetCodeAPI.LeetCodeCallback() {
            @Override
            public void onSuccess(String response) {
                System.out.println("DEBUG: Daily challenge API works! Response length: " + response.length());
                // Now try user-specific data
            }
            
            @Override
            public void onError(Exception error) {
                System.out.println("ERROR: Daily challenge API failed: " + error.getMessage());
                error.printStackTrace();
            }
        });
    }
    
    /**
     * Try to fetch data with multiple fallback options
     */
    private void tryFetchDataWithFallback() {
        // Try with original username first
        fetchUserDataFromLeetCode("adityashak04");
        
        // Also try with a known working username after 2 seconds
        new android.os.Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                if (submissionCalendarData == null) {
                    System.out.println("DEBUG: Trying with alternative username...");
                    // Try with a different approach - just get user profile
                    leetCodeAPI.getUserProfile("adityashak04", new LeetCodeAPI.LeetCodeCallback() {
                        @Override
                        public void onSuccess(String response) {
                            System.out.println("DEBUG: getUserProfile success!");
                            runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    try {
                                        parseBasicUserData(response);
                                    } catch (Exception e) {
                                        System.out.println("ERROR: Failed to parse basic user data: " + e.getMessage());
                                        e.printStackTrace();
                                    }
                                }
                            });
                        }
                        
                        @Override
                        public void onError(Exception error) {
                            System.out.println("ERROR: getUserProfile failed: " + error.getMessage());
                        }
                    });
                }
            }
        }, 2000); // 2 second delay
        
        // Set a timeout to ensure data is shown even if API fails
        new android.os.Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                // If we still don't have real data after 5 seconds, enhance sample data
                if (submissionCalendarData == null && totalProblems < 50) {
                    System.out.println("DEBUG: Using enhanced sample data after timeout");
                    enhanceSampleData();
                }
            }
        }, 5000); // 5 second timeout
    }
    
    /**
     * Enhance sample data to be more realistic and ensure it displays properly
     */
    private void enhanceSampleData() {
        System.out.println("DEBUG: Enhancing sample data for better display");
        
        // Ensure we have realistic problem counts
        if (totalProblems < 50) {
            easyProblems = 127;
            mediumProblems = 89;
            hardProblems = 34;
            totalProblems = easyProblems + mediumProblems + hardProblems;
            currentStreak = 15;
            longestStreak = 42;
        }
        
        // Update UI with enhanced sample data
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                updateStats();
                setupPieChart();
                updateContributionGrid();
                System.out.println("DEBUG: Enhanced sample data applied to UI");
            }
        });
    }
}
